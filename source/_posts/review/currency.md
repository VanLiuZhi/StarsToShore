## 基础与名词解释

竞态条件: 多个线程竞争同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件
临界区: 导致竞态条件发生的代码称为临界区

Java运行至少启动两个线程，一个是main线程，一个是垃圾回收线程;Java启动的每一个进程都有一个独立的JVM

JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证(也就是线程A要向线程B发送消息，线程A要把数据先写到主内存，由线程B去主内存读取数据)

Java内存模型没有具体讲述前面讨论的执行策略是由编译器，CPU，缓存控制器还是其它机制促成的。甚至没有用开发人员所熟悉的类，对象及方法来讨论。取而代之，Java内存模型中仅仅定义了线程和内存之间那种抽象的关系。众所周知，每个线程都拥有自己的工作存储单元（缓存和寄存器的抽象）来存储线程当前使用的变量的值。Java内存模型仅仅保证了代码指令与变量操作的有序性，大多数规则都只是指出什么时候变量值应该在内存和线程工作内存之间传输。这些规则主要是为了解决如下三个相互牵连的问题：

1. 原子性：哪些指令必须是不可分割的。在Java内存模型中，这些规则需声明仅适用于-—实例变量和静态变量，也包括数组元素，但不包括方法中的局部变量-—的内存单元的简单读写操作。
2. 可见性：在哪些情况下，一个线程执行的结果对另一个线程是可见的。这里需要关心的结果有，写入的字段以及读取这个字段所看到的值。
3. 有序性：在什么情况下，某个线程的操作结果对其它线程来看是无序的。最主要的乱序执行问题主要表现在读写操作和赋值语句的相互执行顺序上。

访问临界区，需要获取到锁，操作完，释放锁。而对于锁本身，也是一种临界资源，是不允许多个线程共同持有的，同一时刻，只能够一个线程持有

Java中有另外一个概念，叫做监视器，《深入Java虚拟机》中如下描述监视器：

可以将监视器比作一个建筑，它有一个很特别的房间，房间里有一些数据，而且在同一时间只能被一个线程占据。
一个线程从进入这个房间到它离开前，它可以独占地访问房间中的全部数据。如果用一些术语来定义这一系列动作：

进入这个建筑叫做“进入监视器”
进入建筑中的那个特别的房间叫作“获得监视器”
占据房间叫做“持有监视器”
离开房间叫做“释放监视器”
离开建筑叫做“退出监视器”

（对于开发者来说，你使用一个synchronized关键字就有了监视器的效果，监视器依赖JVM，而JVM依赖操作系统，操作系统则会进一步依赖软件甚至硬件，就是这样层层封装）
其实废话这么多，一个同步方法内（同步代码块）中所有的内容，就是属于同一个监视区域

现代处理器，单CPU多核，共享三级缓存，每个核心有2个二级缓存，上面是一级缓存。数据必须通过缓存加载到寄存器，CPU不会直接从内存加载数据

要理解JMM是一种抽象的概念，不是真实存在的，是一组规则，通过这组规则控制程序中各个变量在共享数据域和私有数据域的访问方式，什么规则呢？
就是围绕原子性，可见性，有序性展开的

## 并发编程模型的分类

`在并发编程中，我们需要处理两个关键问题：`

线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体），通信是指线程之间以何种机制来交换信息。

`在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递`

在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。
在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。

`同步是指程序用于控制不同线程之间操作发生相对顺序的机制`

在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。
在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

## JMM

Java线程之间的通信由Java内存模型（简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。

从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。

## 创建线程

- 实现Runnable接口
- 继承Thread类

```java
package currency;

public class MyThread implements Runnable {
    @Override
    public void run() {
        System.out.println("run method");
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new MyThread());
        thread.start();
        System.out.println("线程唯一标识符：" + thread.getId());
        System.out.println("线程名称：" + thread.getName());
        System.out.println("线程状态：" + thread.getState());
        System.out.println("线程优先级：" + thread.getPriority());
    }
}

class MyThread2 extends Thread {

    @Override
    public void run() {
        System.out.println("run myThread2");
    }

    public static void main(String[] args) {
        MyThread2 myThread2 = new MyThread2();
        myThread2.start();
    }
}
```

## 线程优先级

从1到10，1最低，10最高

## 线程状态

new 新建
runnable 可运行
blocked 阻塞
waiting 等待
time waiting 定时等待
terminated 终止

状态转换流程

1. 线程创建，进入new状态
2. 调用 start 或者 run 方法，进入 runnable 状态
3. JVM 按照线程优先级及时间分片等执行 runnable 状态的线程。开始执行时，进入 running 状态
4. 如果线程执行 sleep、wait、join，或者进入 IO 阻塞等。进入 wait 或者 blocked 状态
5. 线程执行完毕后，线程被线程队列移除。最后为 terminated 状态

## 缓存一致性协议

CPU多个核是共享内存的，当2个核都要去操作变量i的时候，如何保证数据一致性？

方式:

1. 总线加锁(非常耗损性能)
2. 缓存一致性协议

现代处理器通过操作系统和处理器架构，配合特定的指令集实现缓存一致性

比较常见的协议: MESI

M 修改
E 独占
S 共享
I 无效

流程举例:

1. 主存有变量i，CPU1读取变量i，变量变成E(独占)
2. CPU2读取变量i，通过广播和`总线嗅探机制`，此时变量i在CPU1和CPU2中都变成S(共享)
3. CPU1修改了变量i，在CPU1中，i变成M(修改)，通过总线嗅探，CPU2中i变成I(无效)
4. 如果CPU2需要用到i，就需要从主存重新读取，此时就等待CPU1的i回写到主存。注意CPU1修改了i之后，由于CPU2的i I(无效)，此时CPU1的i是E(独占)，并且这个修改不会直接写到主存，需要在某个特定的时间点才会写入
5. i写入后，CPU2读取到，此时CPU1和CPU2的i又变成S(共享)


### 锁缓存行

通过LOCK指令来实现的缓存一致性协议，有一个缓存行的概念 cache line 64byte

什么情况下不能用缓存一致性协议

1. 不支持(现代处理器都支持)
2. 跨缓存行，就是超过了cache line的大小，此时就会用锁总线

`/sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size` 感兴趣可以看看这里的东西，这个文件记录了cache line大小，为64

### 缓存淘汰策略

LRU 最近最少使用的，会被淘汰掉，在CPU的cache中就是被踢出了

