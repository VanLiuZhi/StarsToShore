---
title: Future
date: 2020-03-30 00:00:00
author: vanliuzh
top: true
cover: false
toc: true
mathjax: false
categories: Java
tags: [Java, Note]
reprintPolicy: cc_by
---

# Conncurrennt 并发

并发编程JUC知识点总结

## 知识点概况

1. 竞态条件和临界资源

2. JMM -- Java Memony Model 是一种抽象，一组规则，围绕着3个特性展开，如何做到这三点就是我们需要理解的

    1. 原子性
    2. 有序性
    3. 可见性

3. 监视器 Monitor

4. JTI 即时编译，通过热点探测（对程序计数统计）

5. 并发编程模型

    线程如何`通信`和`同步`

6. 上下文: 某一时间点，CPU寄存器和计数器的内容(还有栈信息等)，线程只需要保存这些内容做切换

线程的上下文信息是保存在内存中的，切换回来的时候去内存中找到然后恢复到寄存器中

## 创建线程的方式

1. 实现Runable接口
2. 继承Thread类
3. 实现Callable接口

1，2都是类似的，3是用线程池

## start 和 run 方法的区别

start方法会创建线程，进入就绪状态，分配到时间的时候片执行run方法
直接用run方法不会有多线程，就和普通的方法一样

## 线程状态

1. wait(),join(),LockSupport.lock()方法线程会进入到WAITING

2. wait(long timeout)，sleep(long),join(long),LockSupport.parkNanos(),LockSupport.parkUtil()增加了超时等待的功能，也就是调用这些方法后线程会进入TIMED_WAITING

3. 当超时等待时间到达后，线程会切换到Runable的状态，另外当WAITING和TIMED_WAITING状态时可以通过Object.notify(),Object.notifyAll()方法使线程转换到Runable状态

4. 当线程出现资源竞争时，即等待获取锁的时候，线程会进入到BLOCKED阻塞状态

5. 当线程获取锁时，线程进入到Runable状态

6. 线程运行结束后，线程进入到TERMINATED状态

7. 当线程进入到synchronized方法或者synchronized代码块时，线程切换到的是BLOCKED状态，而使用java.util.concurrent.locks下lock进行加锁的时候线程切换的是WAITING或者TIMED_WAITING状态，因为lock会调用LockSupport的方法。

## 线程基本操作

1. interrupted 中断

主要关注标志位的状态，标志位用来做判断，
interrupted interrupt isInterrupted

2. join

3. sleep

sleep线程不会失去锁

sleep()方法是Thread的静态方法，而wait是Object实例方法

wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。
而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；

sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行

4. yield

调用后当前线程让出时间片，拥有同级别优先级的线程可以去竞争该时间片，让出时间片后，加入到下一次的cpu资源竞争中

## 获取线程的状态

```java
System.out.println("线程唯一标识符：" + thread.getId());
System.out.println("线程名称：" + thread.getName());
System.out.println("线程状态：" + thread.getState());
System.out.println("线程优先级：" + thread.getPriority());
```

## notify notifyAll 

## Daemon 守护线程

一个进程包含主线程，2个子线程，1个守护线程

主线程任务完成了，子线程任务也完成了，这个时候守护线程会自己结束，不管任务有没有完成

## 什么是线程安全？

当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。

## 线程通信，消费者和生产者编程实践

## Java中共享变量是哪些？

方法中的局部变量不是共享的，实例域，静态域和数组元素都是在堆内存中的，是共享的

## Java内存模型

## 重排序

分类

1. 编译器优化的重排序

编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序

2. 指令级并行的重排序

现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序

3. 内存系统的重排序

由于处理器使用缓存，读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的，详细说明下这种情况

举例: 

- 什么是缓冲区

发生这种情况是由于处理器使用了缓冲区，比如对变量的写入先写到缓冲区，然后再刷新到主存(现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟)

- 场景

理解这个概念后，有一段代码执行顺序是这样的，A，B线程，先写a=1，b=2到主存，然后读取主存共享变量 a=b=0

- 执行情况

内存的操作情况是 写，然后读(`写->读`) 然而有缓冲区，可能是写到缓冲区后，读主存，然后缓冲区刷新到主存(`读->写`)

- 结论

由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。可以用

常见的处理器都允许Store-Load重排序；
常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO和x86拥有相对较强的处理器内存模型，它们`仅允许对写-读操作做重排序`（因为它们都使用了写缓冲区）

- 通过内存屏障解决重排序问题

Java编译器通过插入内存屏障来解决重排序，内存屏障是指令，依托于处理器的实现，使用内存屏障有一定的性能损坏，因为原来通过缓冲区加快了处理器指令流水的运行，使用内存屏障就是要先把缓冲区数据刷新到主存后，才执行后面的指令

- 内存屏障指令举例 

`LoadLoad Barriers`    

Load1; LoadLoad; Load2   确保Load1数据的装载，之前于Load2及所有后续装载指令的装载

`StoreLoad Barriers`   

Store1; StoreStore; Store2  确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储

`LoadStore Barriers`   

Load1; LoadStore; Store2   确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存

`StoreLoad Barriers`   

Store1; StoreLoad; Load2   确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令

- 内存屏障总结

StoreLoad Barriers 是现代处理器都会支持的(其它的不一定)。总的来说内存屏障指令之前的指令，会先执行，有写操作的都要刷新主存后，后面的指令才执行，这样后面的指令就能读到前一个指令写入的数据(从主存读)，实现了数据的可见性

`重排序`

对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序(不是所有的编译器重排序都要禁止)。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障(memory barriers，intel称之为memory fence)指令，通过内存屏障指令来禁止特定类型的处理器重排序(不是所有的处理器重排序都要禁止)

JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证

总结: 重排序是对Java源代码编译后的字节码做排序，现代处理都能并行处理，也就是一次执行多条指令，而旧体系的处理器或者单片机是按照时钟周期一条一条指令执行的。编译器编译源代码，处理器去执行语句都可能发生重排序


## 什么时候不能重排序？

发生数据依赖的时候，不能重排序

如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性，体现在`有写操作`上

读后写，写后读，写后写 都是数据依赖  读后读  没关系，都是读取

## as-if-serial

遵守as-if-serial语义的编译器，runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的

## happens-before

通过happens-before来描述内存可见性，或者说是`用来描述可见性的一种规则`

# 微服务

## 让你去实现一个注册中心，你会怎么做？

## 让你实现一个消息中间件，比如kafka，你会怎么做？