---
title: Java review 并发
date: 2019-04-05 00:00:00
tags: [java, note]
categories: Java
---

review

<!-- more -->

## 基础与名词解释

竞态条件: 多个线程竞争同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件
临界区: 导致竞态条件发生的代码称为临界区

Java运行至少启动两个线程，一个是main线程，一个是垃圾回收线程(当然实际肯定不止，还有其它线程协调其它工作);Java启动的每一个进程都有一个独立的JVM

JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证(也就是线程A要向线程B发送消息，线程A要把数据先写到主内存，由线程B去主内存读取数据)

Java内存模型没有具体讲述前面讨论的执行策略是由编译器，CPU，缓存控制器还是其它机制促成的。甚至没有用开发人员所熟悉的类，对象及方法来讨论。取而代之，Java内存模型中仅仅定义了线程和内存之间那种抽象的关系。众所周知，每个线程都拥有自己的工作存储单元（缓存和寄存器的抽象）来存储线程当前使用的变量的值。Java内存模型仅仅保证了代码指令与变量操作的有序性，大多数规则都只是指出什么时候变量值应该在内存和线程工作内存之间传输。这些规则主要是为了解决如下三个相互牵连的问题：

1. 原子性：哪些指令必须是不可分割的。在Java内存模型中，这些规则需声明仅适用于-—实例变量和静态变量，也包括数组元素，但不包括方法中的局部变量-—的内存单元的简单读写操作。
2. 可见性：在哪些情况下，一个线程执行的结果对另一个线程是可见的。这里需要关心的结果有，写入的字段以及读取这个字段所看到的值。
3. 有序性：在什么情况下，某个线程的操作结果对其它线程来看是无序的。最主要的乱序执行问题主要表现在读写操作和赋值语句的相互执行顺序上。

访问临界区，需要获取到锁，操作完，释放锁。而对于锁本身，也是一种临界资源，是不允许多个线程共同持有的，同一时刻，只能够一个线程持有

Java中有另外一个概念，叫做监视器，《深入Java虚拟机》中如下描述监视器：

可以将监视器比作一个建筑，它有一个很特别的房间，房间里有一些数据，而且在同一时间只能被一个线程占据。
一个线程从进入这个房间到它离开前，它可以独占地访问房间中的全部数据。如果用一些术语来定义这一系列动作：

进入这个建筑叫做“进入监视器”
进入建筑中的那个特别的房间叫作“获得监视器”
占据房间叫做“持有监视器”
离开房间叫做“释放监视器”
离开建筑叫做“退出监视器”

（对于开发者来说，你使用一个synchronized关键字就有了监视器的效果，监视器依赖JVM，而JVM依赖操作系统，操作系统则会进一步依赖软件甚至硬件，就是这样层层封装）
其实废话这么多，一个同步方法内（同步代码块）中所有的内容，就是属于同一个监视区域

现代处理器，单CPU多核，共享三级缓存，每个核心有2个二级缓存，上面是一级缓存。数据必须通过缓存加载到寄存器，CPU不会直接从内存加载数据

要理解JMM是一种抽象的概念，不是真实存在的，是一组规则，通过这组规则控制程序中各个变量在共享数据域和私有数据域的访问方式，什么规则呢？
就是围绕原子性，可见性，有序性展开的

操作系统进程创建调用fork，线程的创建调用pthread_create 都是c++提供的，主要是说Linux

编译优化: JIT除了具有缓存的功能外，还会对代码做各种优化。比如 逃逸分析、 锁消除、 锁膨胀、 方法内联、 空值检查消除、 类型检测消除、公共子表达式消除

JTI即时编译，通过热点探测机制把解释器翻译执行的热点代码编译成机器码，缓存起来，方便下次调用，通过对栈顶计数，对程序计数(超过阈值认为它是热点代码)，然后触发JIT，在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器:方法调用计数器和回边计数器

## 并发编程模型的分类

`在并发编程中，我们需要处理两个关键问题：`

线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体），通信是指线程之间以何种机制来交换信息。

`在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递`

在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。
在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。

`同步是指程序用于控制不同线程之间操作发生相对顺序的机制`

在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。
在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

## JMM

Java线程之间的通信由Java内存模型（简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。

从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。

## JMM相关操作

lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态
unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量
store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中

这个只需要知道个大概就行了:

从主存复制到工作内存 -> 就需要按顺序地执行read和load操作
从工作内存复制到主存 -> 就需要按顺序地执行store和write操作

## Java内存模型同步规则

不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中

一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作

一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现

如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值

如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）

## volatile

volatile缓存可见性实现原理

JMM内存交互层面：volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步会主内存，使用时必须从主内存刷新，由此保证volatile变量的可见性。
底层实现：通过汇编lock前缀指令，它会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存内存会导致其他处理器的缓存无效

汇编代码查看 -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp (可以借助idea工具，把参数加到执行后面，观察汇编指令)

## 创建线程

- 实现Runnable接口
- 继承Thread类

```java
package concurrent;

public class MyThread implements Runnable {
    @Override
    public void run() {
        System.out.println("run method");
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new MyThread());
        thread.start();
        System.out.println("线程唯一标识符：" + thread.getId());
        System.out.println("线程名称：" + thread.getName());
        System.out.println("线程状态：" + thread.getState());
        System.out.println("线程优先级：" + thread.getPriority());
    }
}

class MyThread2 extends Thread {

    @Override
    public void run() {
        System.out.println("run myThread2");
    }

    public static void main(String[] args) {
        MyThread2 myThread2 = new MyThread2();
        myThread2.start();
    }
}
```

## 线程优先级

从1到10，1最低，10最高

## 线程状态

new 新建
runnable 可运行
blocked 阻塞
waiting 等待
time waiting 定时等待
terminated 终止

状态转换流程

1. 线程创建，进入new状态
2. 调用 start 或者 run 方法，进入 runnable 状态
3. JVM 按照线程优先级及时间分片等执行 runnable 状态的线程。开始执行时，进入 running 状态
4. 如果线程执行 sleep、wait、join，或者进入 IO 阻塞等。进入 wait 或者 blocked 状态
5. 线程执行完毕后，线程被线程队列移除。最后为 terminated 状态

## 缓存一致性协议

CPU多个核是共享内存的，当2个核都要去操作变量i的时候，如何保证数据一致性？

方式:

1. 总线加锁(非常耗损性能)
2. 缓存一致性协议

现代处理器通过操作系统和处理器架构，配合特定的指令集实现缓存一致性

比较常见的协议: MESI

M 修改 Modified
E 独占 Exclusive
S 共享 Shared
I 无效 Invalid

流程举例:

1. 主存有变量i，CPU1读取变量i，变量变成E(独占)
2. CPU2读取变量i，通过广播和`总线嗅探机制`，此时变量i在CPU1和CPU2中都变成S(共享)
3. CPU1修改了变量i，在CPU1中，i变成M(修改)，通过总线嗅探，CPU2中i变成I(无效)
4. 如果CPU2需要用到i，就需要从主存重新读取，此时就等待CPU1的i回写到主存。注意CPU1修改了i之后，由于CPU2的i I(无效)，此时CPU1的i是E(独占)，并且这个修改不会直接写到主存，需要在某个特定的时间点才会写入
5. i写入后，CPU2读取到，此时CPU1和CPU2的i又变成S(共享)


### 锁缓存行

通过LOCK指令来实现的缓存一致性协议，有一个缓存行的概念 cache line 64byte

什么情况下不能用缓存一致性协议

1. 不支持(现代处理器都支持)
2. 跨缓存行，就是超过了cache line的大小，此时就会用锁总线

`/sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size` 感兴趣可以看看这里的东西，这个文件记录了cache line大小，为64

### 缓存淘汰策略

LRU 最近最少使用的，会被淘汰掉，在CPU的cache中就是被踢出了



